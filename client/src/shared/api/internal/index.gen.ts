// Messenger server 1.0.0
// ---
// This file is automatically generated by openapi with preset effector-openapi-preset
// Do not edit this file directly. Instead open openapi config file and follow the link in "file"
import { createEffect } from 'effector';
import * as typed from 'typed-contracts';
import { sendRequestFx } from '@lm-client/shared/api/request';

//#region prebuilt code
const custom = { any: (valueName: string, value: unknown): any => value };

export type GenericErrors =
  | {
      status: 'unexpected';
      error: Error;
    }
  | {
      status: 'unknown_status';
      error: { status: number; body: unknown };
    }
  | {
      status: 'validation_error';
      error: typed.ValidationError;
    };

type ErrorCodes =
  | 400
  | 401
  | 402
  | 403
  | 404
  | 405
  | 406
  | 500
  | 501
  | 502
  | 503
  | 503
  | 505;
/**
 * @throws
 */
function parseByStatus<
  Variants extends string,
  Contracts extends Record<number, [Variants, typed.Contract<any>]>,
  Result extends {
    [Code in keyof Contracts]: Contracts[Code] extends [
      infer Status,
      typed.Contract<infer T>
    ]
      ? { status: Status; answer: T }
      : never;
  }
>(
  name: string,
  response: { status: number; body?: unknown },
  contracts: Contracts
): Result[Exclude<keyof Result, ErrorCodes>] {
  const contractObject = contracts[response.status];
  if (!contractObject) {
    throw {
      status: 'unknown_status',
      error: {
        status: response.status,
        body: response.body,
      },
    };
  }
  const [status, contract] = contractObject;
  const answer = contract(name, response.body);
  if (answer instanceof typed.ValidationError) {
    throw { status: 'validation_error', error: answer };
  }
  if (response.status >= 400) {
    throw { status, error: answer };
  }
  return { status, answer } as Result[Exclude<keyof Result, ErrorCodes>];
}

//#endregion prebuilt code/* --- */
//#region pingGet
export type PingGet = {};
/* Default Response */ export const pingGetOk = typed.nul;
export type PingGetDone = {
  status: 'ok';
  answer: typed.Get<typeof pingGetOk>;
};
export type PingGetFail = GenericErrors;
export const pingGet = createEffect<PingGet, PingGetDone, PingGetFail>({
  async handler() {
    const name = 'pingGet.body';
    const response = await sendRequestFx({
      path: '/ping',
      method: 'GET',
    });
    return parseByStatus(name, response, {
      200: ['ok', pingGetOk],
    });
  },
});
//#endregion pingGet

/* --- */
//#region authLocalSignUpPost
export type AuthLocalSignUpPost = {
  body?: {
    body?: {
      username: string;
      password: string;
      phoneNumber: string;
      email: string;
    };
  };
};
/* Success Response */ export const authLocalSignUpPostCreated = typed.nul;
export type AuthLocalSignUpPostDone = {
  status: 'created';
  answer: typed.Get<typeof authLocalSignUpPostCreated>;
};
/* Failure Response */ export const authLocalSignUpPostForbidden = typed.nul;
export type AuthLocalSignUpPostFail =
  | {
      status: 'forbidden';
      error: typed.Get<typeof authLocalSignUpPostForbidden>;
    }
  | GenericErrors;
/* Sign up request */ export const authLocalSignUpPost = createEffect<
  AuthLocalSignUpPost,
  AuthLocalSignUpPostDone,
  AuthLocalSignUpPostFail
>({
  async handler({ body }) {
    const name = 'authLocalSignUpPost.body';
    const response = await sendRequestFx({
      path: '/auth/local/sign-up',
      method: 'POST',
      body,
    });
    return parseByStatus(name, response, {
      201: ['created', authLocalSignUpPostCreated],
      403: ['forbidden', authLocalSignUpPostForbidden],
    });
  },
});
//#endregion authLocalSignUpPost

/* --- */
//#region authLocalSignInPost
export type AuthLocalSignInPost = {
  body?: {
    body?: {
      email: string;
      password: string;
    };
  };
};
/* Success Response */ export const authLocalSignInPostOk = typed.nul;
export type AuthLocalSignInPostDone = {
  status: 'ok';
  answer: typed.Get<typeof authLocalSignInPostOk>;
};
/* Failure Response if we put incorrect credentials */ export const authLocalSignInPostBadRequest =
  typed.nul;
export type AuthLocalSignInPostFail =
  | {
      status: 'bad_request';
      error: typed.Get<typeof authLocalSignInPostBadRequest>;
    }
  | GenericErrors;
/* Sign in request */ export const authLocalSignInPost = createEffect<
  AuthLocalSignInPost,
  AuthLocalSignInPostDone,
  AuthLocalSignInPostFail
>({
  async handler({ body }) {
    const name = 'authLocalSignInPost.body';
    const response = await sendRequestFx({
      path: '/auth/local/sign-in',
      method: 'POST',
      body,
    });
    return parseByStatus(name, response, {
      200: ['ok', authLocalSignInPostOk],
      400: ['bad_request', authLocalSignInPostBadRequest],
    });
  },
});
//#endregion authLocalSignInPost

/* --- */
//#region authLocalRefreshPost
export type AuthLocalRefreshPost = {};
/* Success Response */ export const authLocalRefreshPostOk = typed.nul;
export type AuthLocalRefreshPostDone = {
  status: 'ok';
  answer: typed.Get<typeof authLocalRefreshPostOk>;
};
/* Unauthorized, if missing or invalid refresh token */ export const authLocalRefreshPostUnauthorized =
  typed.nul;
/* if missing refresh token(this error did'nt work because refresh token check onRequest and throw 401 exception) */ export const authLocalRefreshPostForbidden =
  typed.nul;
export type AuthLocalRefreshPostFail =
  | {
      status: 'unauthorized';
      error: typed.Get<typeof authLocalRefreshPostUnauthorized>;
    }
  | {
      status: 'forbidden';
      error: typed.Get<typeof authLocalRefreshPostForbidden>;
    }
  | GenericErrors;
/* Refresh token request */ export const authLocalRefreshPost = createEffect<
  AuthLocalRefreshPost,
  AuthLocalRefreshPostDone,
  AuthLocalRefreshPostFail
>({
  async handler() {
    const name = 'authLocalRefreshPost.body';
    const response = await sendRequestFx({
      path: '/auth/local/refresh',
      method: 'POST',
    });
    return parseByStatus(name, response, {
      200: ['ok', authLocalRefreshPostOk],
      401: ['unauthorized', authLocalRefreshPostUnauthorized],
      403: ['forbidden', authLocalRefreshPostForbidden],
    });
  },
});
//#endregion authLocalRefreshPost

/* --- */
//#region authLocalLogoutPost
export type AuthLocalLogoutPost = {};
/* Success Response */ export const authLocalLogoutPostOk = typed.nul;
export type AuthLocalLogoutPostDone = {
  status: 'ok';
  answer: typed.Get<typeof authLocalLogoutPostOk>;
};
/* If don't have access token or token invalid */ export const authLocalLogoutPostUnauthorized =
  typed.nul;
export type AuthLocalLogoutPostFail =
  | {
      status: 'unauthorized';
      error: typed.Get<typeof authLocalLogoutPostUnauthorized>;
    }
  | GenericErrors;
/* Logout request */ export const authLocalLogoutPost = createEffect<
  AuthLocalLogoutPost,
  AuthLocalLogoutPostDone,
  AuthLocalLogoutPostFail
>({
  async handler() {
    const name = 'authLocalLogoutPost.body';
    const response = await sendRequestFx({
      path: '/auth/local/logout',
      method: 'POST',
    });
    return parseByStatus(name, response, {
      200: ['ok', authLocalLogoutPostOk],
      401: ['unauthorized', authLocalLogoutPostUnauthorized],
    });
  },
});
//#endregion authLocalLogoutPost

/* --- */
//#region userMeGet
export type UserMeGet = {};
/* Default Response */ export const userMeGetOk = typed.nul;
export type UserMeGetDone = {
  status: 'ok';
  answer: typed.Get<typeof userMeGetOk>;
};
export type UserMeGetFail = GenericErrors;
export const userMeGet = createEffect<UserMeGet, UserMeGetDone, UserMeGetFail>({
  async handler() {
    const name = 'userMeGet.body';
    const response = await sendRequestFx({
      path: '/user/me',
      method: 'GET',
    });
    return parseByStatus(name, response, {
      200: ['ok', userMeGetOk],
    });
  },
});
//#endregion userMeGet

/* --- */
//#region userGet
export type UserGet = {};
/* Default Response */ export const userGetOk = typed.nul;
export type UserGetDone = {
  status: 'ok';
  answer: typed.Get<typeof userGetOk>;
};
export type UserGetFail = GenericErrors;
export const userGet = createEffect<UserGet, UserGetDone, UserGetFail>({
  async handler() {
    const name = 'userGet.body';
    const response = await sendRequestFx({
      path: '/user/',
      method: 'GET',
    });
    return parseByStatus(name, response, {
      200: ['ok', userGetOk],
    });
  },
});
//#endregion userGet
